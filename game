<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Neon Strike 2.3 Ultra</title>
<style>
body{margin:0;background:#111;overflow:hidden;font-family:Arial,sans-serif;}
canvas{display:block;margin:auto;background:#111;}
#startScreen{
  position:absolute;top:0;left:0;width:100%;height:100%;
  display:flex;flex-direction:column;justify-content:center;align-items:center;
  background:#111;color:#0ff;z-index:1000;
  animation: fadeIn 1s ease-in-out;
}
@keyframes fadeIn{from{opacity:0;}to{opacity:1;}}
#startScreen h1{font-size:60px;margin-bottom:50px;text-shadow:0 0 20px #0ff;animation: glow 1.5s infinite alternate;}
@keyframes glow{0%{text-shadow:0 0 20px #0ff;}100%{text-shadow:0 0 40px #0ff;}}
#startScreen button{
  font-size:30px;padding:15px 50px;cursor:pointer;border:none;background:#0ff;color:#111;
  transition: all 0.2s ease;border-radius:10px;box-shadow:0 0 20px #0ff;
  animation: btnPulse 1s infinite alternate;
}
#startScreen button:hover{transform: scale(1.1);box-shadow:0 0 30px #0ff;}
#startScreen button:active{transform: scale(0.95);}
@keyframes btnPulse{0%{box-shadow:0 0 20px #0ff;}100%{box-shadow:0 0 40px #0ff;}}
</style>
</head>
<body>

<div id="startScreen">
  <h1>Neon Strike 2.3 [NS]</h1>
  <button id="startBtn">Start</button>
</div>

<audio id="bgm" src="https://freesound.org/data/previews/341/341695_3248240-lq.mp3" loop autoplay></audio>

<canvas id="gameCanvas" width="1600" height="900"></canvas>

<script>
// =================== START SCREEN ===================
const startScreen = document.getElementById('startScreen');
const startBtn = document.getElementById('startBtn');
const bgm = document.getElementById("bgm");
let gameStarted = false;
startBtn.addEventListener('click',()=>{
  startScreen.style.display='none';
  gameStarted = true;
  gameLoop();
  handleShooting();
});

// =================== INPUT ===================
const keys = {};
let mouse = { x:0, y:0, down:false };
document.addEventListener("keydown", e => keys[e.key.toLowerCase()] = true);
document.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);
document.addEventListener("mousemove", e => {
  const rect = canvas.getBoundingClientRect();
  mouse.x = e.clientX - rect.left;
  mouse.y = e.clientY - rect.top;
});
document.addEventListener("mousedown", () => mouse.down = true);
document.addEventListener("mouseup", () => mouse.down = false);

// =================== CANVAS & CAMERA ===================
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const camera = { x:0, y:0, shake:0 };

// =================== PARTICLE SYSTEM ===================
class Particle {
  constructor(x, y, color){
    this.x=x; this.y=y; this.dx=(Math.random()-0.5)*6; this.dy=(Math.random()-0.5)*6;
    this.size=Math.random()*4+2; this.life=30; this.color=color;
  }
  update(){ this.x+=this.dx; this.y+=this.dy; this.life--; }
  draw(){ ctx.fillStyle=this.color; ctx.globalAlpha=Math.max(this.life/30,0); ctx.fillRect(this.x,this.y,this.size,this.size); ctx.globalAlpha=1; }
}
const particles=[];
function spawnParticles(x,y,color,count=10){ for(let i=0;i<count;i++) particles.push(new Particle(x,y,color)); }

// =================== BACKGROUND ===================
const gridLines = [];
for(let i=0;i<100;i++){ gridLines.push({x:Math.random()*canvas.width, y:Math.random()*canvas.height}); }
function drawBackground(){
  ctx.setTransform(1,0,0,1,0,0);
  ctx.fillStyle="#111"; ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.strokeStyle="#0ff"; ctx.lineWidth=1;
  gridLines.forEach(line=>{
    ctx.beginPath();
    ctx.moveTo(line.x, line.y);
    ctx.lineTo(line.x, line.y+20);
    ctx.stroke();
    line.y += 3;
    if(line.y>canvas.height) line.y=0;
  });
}

// =================== WORLD BORDER ===================
function drawWorldBorder(){
  ctx.setTransform(1,0,0,1,0,0);
  ctx.strokeStyle="#ff0";
  ctx.lineWidth=4;
  ctx.strokeRect(0,0,1600,900);
}

// =================== BULLET ===================
class Bullet {
  constructor(x,y,angle, color="#ff0"){
    this.x=x; this.y=y;
    this.dx=Math.cos(angle)*12; this.dy=Math.sin(angle)*12;
    this.size=6; this.color=color;
  }
  update(){ this.x+=this.dx; this.y+=this.dy; }
  draw(){ ctx.fillStyle=this.color; ctx.fillRect(this.x-3,this.y-3,this.size,this.size); }
}

// =================== PLAYER ===================
class Player {
  constructor(){
    this.x=canvas.width/2; this.y=canvas.height/2; this.size=40;
    this.speed=4; this.runSpeed=7; this.angle=0;
    this.health=100; this.maxHealth=100;
    this.ammo=30; this.maxAmmo=30;
    this.isReloading=false; this.reloadCounter=0;
    this.weapons=[]; this.currentWeaponIndex=0;
  }
  update(){
    let s = keys["shift"] ? this.runSpeed : this.speed;
    if(keys["w"]) this.y-=s; if(keys["s"]) this.y+=s;
    if(keys["a"]) this.x-=s; if(keys["d"]) this.x+=s;
    if(this.isReloading){ this.reloadCounter--; if(this.reloadCounter<=0){ this.ammo=this.maxAmmo; this.isReloading=false; } }
    this.angle = Math.atan2(mouse.y-canvas.height/2, mouse.x-canvas.width/2);
    this.weapons[this.currentWeaponIndex].update();
    camera.x+=(this.x-camera.x-canvas.width/2)*0.1;
    camera.y+=(this.y-camera.y-canvas.height/2)*0.1;
  }
  draw(){
    ctx.shadowColor="#0ff"; ctx.shadowBlur=20;
    ctx.fillStyle="#0ff"; ctx.beginPath(); ctx.arc(this.x,this.y,this.size/2,0,Math.PI*2); ctx.fill();
    ctx.shadowBlur=0;
    this.weapons[this.currentWeaponIndex].draw(this);
  }
  reload(){ if(this.ammo<this.maxAmmo && !this.isReloading){ this.isReloading=true; this.reloadCounter=60; } }
}

// =================== WEAPON ===================
class Weapon{
  constructor(name,damage,fireRate,color="#ff0"){ this.name=name; this.damage=damage; this.fireRate=fireRate; this.cooldown=0; this.recoil=0; this.color=color; }
  shoot(player){
    if(this.cooldown>0) return;
    if(player.ammo<=0){ player.reload(); return; }
    const angle=Math.atan2(mouse.y-canvas.height/2, mouse.x-canvas.width/2);
    bullets.push(new Bullet(player.x,player.y,angle,this.color));
    this.recoil=10; camera.shake=5; player.ammo--; this.cooldown=this.fireRate;
    shootSound.currentTime=0; shootSound.play();
    shootSound.play();
  }
  update(){ if(this.cooldown>0)this.cooldown--; this.recoil*=0.85; }
  draw(player){ const angle=Math.atan2(mouse.y-canvas.height/2,mouse.x-canvas.width/2); ctx.save(); ctx.translate(player.x,player.y); ctx.rotate(angle); ctx.fillStyle=this.color; ctx.fillRect(20,-4,30+this.recoil,8); ctx.restore(); }
}

// =================== ENEMY ===================
class Enemy {
  constructor(x,y){ this.x=x; this.y=y; this.size=30; this.speed=1.5; this.hp=10; }
  update(){ 
    const dx=player.x-this.x; const dy=player.y-this.y; 
    const dist=Math.hypot(dx,dy); 
    if(dist>0){ this.x+=(dx/dist)*this.speed; this.y+=(dy/dist)*this.speed; } 
  }
  draw(){ ctx.shadowColor="#f0f"; ctx.shadowBlur=15; ctx.fillStyle="#f0f"; ctx.fillRect(this.x-this.size/2,this.y-this.size/2,this.size,this.size); ctx.shadowBlur=0; }
}

// =================== BOSS ===================
class Boss {
  constructor(x,y){ this.x=x; this.y=y; this.size=120; this.maxHP=500; this.hp=this.maxHP; this.attackTimer=0; }
  update(){
    if(this.hp<=0) return;
    this.attackTimer++;
    const dx=player.x-this.x; const dy=player.y-this.y; const dist=Math.hypot(dx,dy);
    if(dist>0){ this.x+=(dx/dist)*0.8; this.y+=(dy/dist)*0.8; }
    if(this.attackTimer%90===0){
      const angle=Math.atan2(player.y-this.y,player.x-this.x);
      bullets.push(new Bullet(this.x,this.y,angle,"#f0f"));
      camera.shake=5;
    }
  }
  draw(){
    if(this.hp<=0) return;
    ctx.shadowColor="#a0f"; ctx.shadowBlur=20;
    ctx.fillStyle="#a0f"; ctx.fillRect(this.x-this.size/2,this.y-this.size/2,this.size,this.size);
    ctx.shadowBlur=0;
    ctx.setTransform(1,0,0,1,0,0);
    ctx.fillStyle="rgba(0,0,0,0.6)";
    roundRect(ctx, canvas.width/2 - 250, 20, 500, 20, 10, true, true);
    ctx.fillStyle="red";
    roundRect(ctx, canvas.width/2 - 250, 20, 500*(this.hp/this.maxHP), 10, 10, true, false);
    ctx.strokeStyle="#0ff";
    ctx.strokeRect(canvas.width/2 - 250, 20, 500, 20);
  }
}

// =================== GLOBAL ===================
const bullets=[];
const enemies=[];
let kills=0;
for(let i=0;i<5;i++){ enemies.push(new Enemy(Math.random()*1500+50, Math.random()*800+50)); }
let boss=null;
const bossSpawnKills=40;
const player=new Player();
const rifle=new Weapon("Rifle",10,5,"#ff0");
player.weapons=[rifle]; player.currentWeaponIndex=0;
const shootSound=new Audio("https://freesound.org/data/previews/456/456123_512123-lq.mp3");
shootSound.volume=0.5; shootSound.playbackRate=5;
let gameOver=false; let gameWin=false;
let spawnTimer=0;

// =================== UTILITY ===================
function checkCollision(a,b){ const dx=a.x-b.x; const dy=a.y-b.y; const dist=Math.hypot(dx,dy); return dist < (a.size/2 + b.size/2); }
function resolveCollision(a,b){ const overlap=(a.size/2+b.size/2)-Math.hypot(a.x-b.x,a.y-b.y); const angle=Math.atan2(a.y-b.y,a.x-b.x); a.x += Math.cos(angle) * overlap/2; a.y += Math.sin(angle) * overlap/2; b.x -= Math.cos(angle) * overlap/2; b.y -= Math.sin(angle) * overlap/2; }
function roundRect(ctx, x, y, w, h, r, fill, stroke){ if(typeof stroke==="undefined") stroke=true; if(typeof r==="undefined") r=5; ctx.beginPath(); ctx.moveTo(x+r, y); ctx.lineTo(x+w-r, y); ctx.quadraticCurveTo(x+w, y, x+w, y+r); ctx.lineTo(x+w, y+h-r); ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h); ctx.lineTo(x+r, y+h); ctx.quadraticCurveTo(x, y+h, x, y+h-r); ctx.lineTo(x, y+r); ctx.quadraticCurveTo(x, y, x+r, y); ctx.closePath(); if(fill) ctx.fill(); if(stroke) ctx.stroke(); }

// =================== SPAWN SYSTEM ===================
function handleSpawning(){
  spawnTimer++;
  if(spawnTimer>180){
    spawnTimer=0;
    while(enemies.length<5){
      enemies.push(new Enemy(Math.random()*1500+50, Math.random()*800+50));
    }
  }
}

// =================== HUD ===================
function drawHUD(){
    ctx.setTransform(1,0,0,1,0,0);
    ctx.fillStyle="rgba(0,0,0,0.6)"; roundRect(ctx, 20, 20, 200, 20, 10, true, true);
    ctx.fillStyle="red"; roundRect(ctx, 20, 20, 200*(player.health/player.maxHealth), 20, 10, true, false);
    ctx.fillStyle="rgba(0,0,0,0.6)"; roundRect(ctx, 20, 50, 100, 20, 10, true, true);
    ctx.fillStyle="yellow"; roundRect(ctx, 20, 50, 100*(player.ammo/player.maxAmmo), 20, 10, true, false);
    ctx.fillStyle="#0ff"; ctx.font="20px Arial"; ctx.fillText("Kills: "+kills, 20, 90);
    if(boss && boss.hp>0){ ctx.fillStyle="rgba(0,0,0,0.6)"; roundRect(ctx, canvas.width/2-250, 20, 500, 20, 10, true, true); ctx.fillStyle="red"; roundRect(ctx, canvas.width/2-250, 20, 500*(boss.hp/boss.maxHP), 10, 10, true, false); ctx.strokeStyle="#0ff"; ctx.strokeRect(canvas.width/2-250, 20, 500, 20); }
}

// =================== OVERLAY ===================
function drawOverlay(){
    ctx.setTransform(1,0,0,1,0,0);
    ctx.fillStyle="rgba(0,0,0,0.7)";
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle=gameWin?"#0f0":"#f00";
    ctx.font="80px Arial";
    ctx.fillText(gameWin?"YOU WIN!":"GAME OVER",canvas.width/2-200,canvas.height/2);
    ctx.font="30px Arial";
    ctx.fillText("Press ENTER to restart",canvas.width/2-160,canvas.height/2+50);
}

// =================== GAME LOOP ===================
function gameLoop(){
  if(!gameStarted) return;
  drawBackground();
  drawWorldBorder();
  handleSpawning();

  const sx=(Math.random()-0.5)*camera.shake;
  const sy=(Math.random()-0.5)*camera.shake;
  camera.shake*=0.9;
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.translate(-camera.x+sx,-camera.y+sy);

  player.update(); player.draw();

  enemies.forEach(e=>{ e.update(); e.draw(); if(checkCollision(player,e)) resolveCollision(player,e); });
  if(boss && boss.hp>0 && checkCollision(player,boss)) resolveCollision(player,boss);

  bullets.forEach((b,i)=>{
    b.update(); b.draw();
    enemies.forEach((e,ei)=>{
      if(Math.hypot(b.x-e.x,b.y-e.y)<(b.size/2+e.size/2)){
        e.hp-=rifle.damage; spawnParticles(e.x,e.y,"#f0",8);
        if(e.hp<=0){ enemies.splice(ei,1); kills++; }
        bullets.splice(i,1); i--;
      }
    });
    if(boss && boss.hp>0 && Math.hypot(b.x-boss.x,b.y-boss.y)<(b.size/2+boss.size/2)){
        boss.hp-=rifle.damage; spawnParticles(boss.x,boss.y,"#a0f",12); bullets.splice(i,1); i--;
        if(boss.hp<=0) gameWin=true;
    }
  });

  if(kills>=bossSpawnKills && !boss) boss=new Boss(player.x+300,player.y);
  if(boss){ boss.update(); boss.draw(); }

  drawHUD();
  if(player.health<=0) gameOver=true;
  if(gameOver || gameWin) drawOverlay();

  requestAnimationFrame(gameLoop);
}

// =================== SHOOTING ===================
function handleShooting(){ 
    if(mouse.down && !gameOver && !gameWin) player.weapons[player.currentWeaponIndex].shoot(player); 
    requestAnimationFrame(handleShooting); 
}

// =================== RESTART ===================
document.addEventListener("keydown", e=>{
  if((gameOver || gameWin) && e.key==="Enter"){
    location.reload();
  }
});
</script>
</body>
</html>
  
